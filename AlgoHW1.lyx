#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extarticle
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
\size giant
Algo HW 1
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Dani Bondar - 20650856
\end_layout

\end_inset
</cell>
</row>
<row topspace="1cm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size large
Gur Telem - 206631848
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Question 1
\end_layout

\begin_layout Enumerate
A 
\begin_inset Formula $\rightarrow$
\end_inset

 B 
\begin_inset Formula $\rightarrow$
\end_inset

 C 
\begin_inset Formula $\rightarrow$
\end_inset

 F 
\begin_inset Formula $\rightarrow$
\end_inset

 D 
\begin_inset Formula $\rightarrow$
\end_inset

 E
\end_layout

\begin_layout Enumerate
A 
\begin_inset Formula $\rightarrow$
\end_inset

 B 
\begin_inset Formula $\rightarrow$
\end_inset

 F 
\begin_inset Formula $\rightarrow$
\end_inset

 C 
\begin_inset Formula $\rightarrow$
\end_inset

 D 
\begin_inset Formula $\rightarrow$
\end_inset

 E
\end_layout

\begin_layout Enumerate
F 
\begin_inset Formula $\rightarrow$
\end_inset

 B 
\begin_inset Formula $\rightarrow$
\end_inset

 D 
\begin_inset Formula $\rightarrow$
\end_inset

 C 
\begin_inset Formula $\rightarrow$
\end_inset

 A 
\begin_inset Formula $\rightarrow$
\end_inset

 E
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Question 2
\end_layout

\begin_layout Enumerate
False
\end_layout

\begin_layout Enumerate
True
\end_layout

\begin_layout Enumerate
False
\end_layout

\begin_layout Enumerate
False
\end_layout

\begin_layout Enumerate
False
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section
Question 3
\end_layout

\begin_layout Subparagraph
algorithm:
\end_layout

\begin_layout Standard
We will use the Topological sorting algorithm that was though in the tutorial
 that execute in a linear time complexity.
 The only change from the original algorithm would be that now, the end
 result would be a queue of vertices in a topological order, instead of
 a function (a minor implementation detail).
 The following algorithm:
\end_layout

\begin_layout Enumerate
execute the first step of the 
\begin_inset Quotes eld
\end_inset

Topological sorting algorithm
\begin_inset Quotes erd
\end_inset

 - find the root vertices.
 if there more then one root vertex then stop the algorithm and return False.
 There is at list one root vertex - the graph is DAG and thus has no cycles.
\end_layout

\begin_deeper
\begin_layout Enumerate
after every removal of the edges check if there's more then one root in
 the graph - if there is, return False.
\end_layout

\begin_layout Enumerate
continue until there is no more vertices left.
\end_layout

\begin_layout Subparagraph
Correctness: 
\end_layout

\begin_layout Standard
lets assume that there is more then one root in the graph.
 that means that there is no edge that enters to that edge.
 if there is more then one root the graph isn't connected and an Hamiltonian
 path cant be present.
 
\end_layout

\begin_layout Standard
Lets now assume that in the course of the algorithm more then one root vertex
 appears - in that case, an Hamiltonian path cant be present either.
 lets name the two root vertices 
\begin_inset Formula $u$
\end_inset

and 
\begin_inset Formula $v$
\end_inset

.
 if the initial graph had in-fact an Hamiltonian path that means that there
 was a route from, let say, 
\begin_inset Formula $u\rightarrow v$
\end_inset

.
 Because none of the edges between the root vertices (
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

), and the rest of the remaining vertices in the graph, haven't been removed
 - the original route 
\begin_inset Formula $u\rightarrow v$
\end_inset

 went through the deleted vertices.
 lets name the first vertex that exits 
\begin_inset Formula $u$
\end_inset

 in the route 
\begin_inset Formula $u\rightarrow v$
\end_inset

 as 
\begin_inset Formula $w$
\end_inset

.
 
\begin_inset Formula $w$
\end_inset

 was detected before 
\begin_inset Formula $u$
\end_inset

 (because he was a root vertex), but if there's a route 
\begin_inset Formula $u\rightarrow w$
\end_inset

 , there's a circular route in the graph (
\begin_inset Formula $w\rightarrow u\rightarrow w$
\end_inset

), and thats in contradiction to the DAG.
 
\end_layout

\begin_layout Standard
in the end, if at no point we had two roots in the same time, we can say
 that the Hamiltonian path is the order of the roots (the queue).
 and thus we fund an Hamiltonian path.
\end_layout

\begin_layout Subparagraph
Complexity:
\end_layout

\begin_layout Standard
As was tough in the tutorial, the time complexity of the Topological sorting
 algorithm is linear to the input graph - 
\begin_inset Formula $O(V+E)$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
Question 4
\end_layout

\begin_layout Standard
Given a graph 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 and a node 
\begin_inset Formula $s\in V$
\end_inset

, we'll return the length of the shortest cycle with an even number of nodes.
\end_layout

\begin_layout Description
Idea
\end_layout

\begin_layout Standard
We'll create a bigraph like so 
\begin_inset Formula $G'=\left(V',E'\right)$
\end_inset

.
 
\begin_inset Formula 
\[
V'=V\cup\left\{ v'\mid v\in V\backslash\left\{ s\right\} \right\} 
\]

\end_inset

 Meaning, we'll create a duplicate for each node in 
\begin_inset Formula $V$
\end_inset

, except for 
\begin_inset Formula $s$
\end_inset

.
 And
\begin_inset Formula 
\[
E'=\left\{ \left(v,u'\right),\left(v',u\right)\mid v,u\in V\backslash\left\{ s\right\} \wedge\left(v,u\right)\in E\right\} \cup\left\{ \left(v',s\right),\left(s,u'\right)\mid u,v\in V\backslash\left\{ s\right\} \wedge\left(s,u\right),\left(v,s\right)\in E\right\} 
\]

\end_inset

Meaning each original edge in 
\begin_inset Formula $G$
\end_inset

, will appear as an edge from a tagged node to a non tagged node (or the
 other way arround).
 
\begin_inset Formula $s$
\end_inset

 only has a non-tagged version, so it has a special case.
\end_layout

\begin_layout Standard
While building the graph 
\begin_inset Formula $G'$
\end_inset

, for each edge 
\begin_inset Formula $\left(v',s\right)\in E'$
\end_inset

 we add, we'll mark 
\begin_inset Formula $v'\in V'$
\end_inset

 with a boolean flag to indicate it closes a cycle.
\end_layout

\begin_layout Standard
Now, we can use the BFS algorithm to find the distances of each 
\begin_inset Formula $v\in V'$
\end_inset

 from 
\begin_inset Formula $s$
\end_inset

.
 If at one of the iterations, we reached a node that is flagged to close
 a cycle, we'll return the iteration number (first iteration is 
\begin_inset Formula $1$
\end_inset

).
\end_layout

\begin_layout Description
Complexity
\end_layout

\begin_layout Standard
The runtime complexity of the algorithm is
\begin_inset Formula 
\[
O\left(\underset{Building\,G'}{\underbrace{n+m}}+\underset{BFS}{\underbrace{2n+2m}}\right)=O\left(n+m\right)
\]

\end_inset

This can actually be further optimized if we used the SCC algorithm to find
 the only the SCC that contains 
\begin_inset Formula $s$
\end_inset

.
 The optimized solution would be 
\begin_inset Formula $O\left(m\right)$
\end_inset

.
\end_layout

\begin_layout Standard
For that solution we start from 
\begin_inset Formula $s$
\end_inset

 and stop when we need to need to start the next CC.
 Thus, we're left with 
\begin_inset Formula $O\left(m\right)$
\end_inset

 nodes so 
\begin_inset Formula $\left|V'\right|=O\left(m\right)$
\end_inset

.
 Then 
\begin_inset Formula $O\left(n+m\right)=O\left(2m\right)=O\left(m\right)$
\end_inset

.
\end_layout

\begin_layout Description
Correctness
\end_layout

\end_body
\end_document
